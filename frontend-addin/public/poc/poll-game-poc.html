<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Prezo Poll Game PoC</title>
    <style>
      :root {
        --bg-a: #04112b;
        --bg-b: #0a2457;
        --panel: rgba(4, 12, 32, 0.76);
        --panel-border: rgba(121, 190, 255, 0.36);
        --text-main: #e8f2ff;
        --text-sub: #90a5c3;
        --track: rgba(207, 221, 240, 0.2);
        --fill-a: #37d0ff;
        --fill-b: #2d6bff;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        font-family: "Segoe UI", "Trebuchet MS", sans-serif;
        color: var(--text-main);
        background: radial-gradient(120% 120% at 10% 0%, #0f3c91, transparent 60%),
          radial-gradient(100% 120% at 90% 10%, #0a7db8, transparent 55%),
          linear-gradient(140deg, var(--bg-a), var(--bg-b));
        overflow: hidden;
      }

      .grid-bg {
        position: fixed;
        inset: 0;
        background-image: linear-gradient(
            to right,
            rgba(147, 193, 255, 0.1) 1px,
            transparent 1px
          ),
          linear-gradient(to bottom, rgba(147, 193, 255, 0.08) 1px, transparent 1px);
        background-size: 48px 48px;
        opacity: 0.14;
        pointer-events: none;
      }

      .wrap {
        width: min(1100px, 92vw);
        margin: min(7vh, 56px) auto 0;
        padding: 24px 28px 30px;
        border: 1px solid var(--panel-border);
        border-radius: 22px;
        background: var(--panel);
        backdrop-filter: blur(3px);
        box-shadow: 0 24px 80px rgba(3, 7, 23, 0.6);
      }

      .head {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 16px;
      }

      .eyebrow {
        margin: 0 0 8px;
        font-size: 12px;
        letter-spacing: 0.24em;
        text-transform: uppercase;
        color: #8dc2ff;
      }

      h1 {
        margin: 0;
        font-size: clamp(26px, 3.2vw, 42px);
        line-height: 1.08;
        max-width: 900px;
      }

      .meta {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        border: 1px solid rgba(143, 190, 255, 0.33);
        border-radius: 999px;
        padding: 8px 14px;
        font-size: 14px;
        color: var(--text-sub);
        white-space: nowrap;
      }

      .dot {
        width: 9px;
        height: 9px;
        border-radius: 999px;
        background: #58f08c;
        box-shadow: 0 0 0 0 rgba(88, 240, 140, 0.75);
        animation: pulse 1.8s infinite;
      }

      .state {
        margin-top: 18px;
      }

      .option {
        margin-top: 14px;
      }

      .label-row {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 7px;
      }

      .label {
        font-size: clamp(16px, 2vw, 24px);
        font-weight: 700;
        line-height: 1.2;
      }

      .stats {
        color: var(--text-sub);
        font-size: clamp(14px, 1.5vw, 20px);
      }

      .track {
        position: relative;
        width: 100%;
        height: clamp(16px, 2.1vw, 28px);
        border-radius: 999px;
        background: var(--track);
        overflow: hidden;
      }

      .fill {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        width: 0%;
        border-radius: 999px;
        background: linear-gradient(90deg, var(--fill-a), var(--fill-b));
        transition: width 420ms cubic-bezier(0.22, 1, 0.36, 1);
        box-shadow: 0 0 20px rgba(55, 206, 255, 0.43);
      }

      .empty {
        color: var(--text-sub);
        font-size: 18px;
        margin-top: 18px;
      }

      .footer {
        margin-top: 20px;
        color: #8ea3c4;
        font-size: 13px;
      }

      .footer code {
        color: #c9e4ff;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(88, 240, 140, 0.6);
        }
        70% {
          box-shadow: 0 0 0 8px rgba(88, 240, 140, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(88, 240, 140, 0);
        }
      }
    </style>
  </head>
  <body>
    <div class="grid-bg"></div>
    <main class="wrap">
      <section class="head">
        <div>
          <p class="eyebrow">Prezo Game Mode PoC</p>
          <h1 id="question">Waiting for poll data...</h1>
        </div>
        <div class="meta">
          <span class="dot"></span>
          <span id="status">connecting</span>
          <span id="votes">0 votes</span>
        </div>
      </section>
      <section class="state" id="options"></section>
      <p class="footer" id="footer"></p>
    </main>

    <script>
      ;(() => {
        const params = new URLSearchParams(window.location.search)
        const rawSessionId = params.get("sessionId")
        const initialSessionId = rawSessionId ? rawSessionId.trim() : ""
        const rawCode =
          params.get("code") || params.get("joinCode") || params.get("sessionCode")
        const sessionCode = rawCode ? rawCode.trim().toUpperCase() : ""
        const boundPollId = params.get("pollId")
        const apiBase = params.get("apiBase") || window.location.origin
        const statusEl = document.getElementById("status")
        const votesEl = document.getElementById("votes")
        const questionEl = document.getElementById("question")
        const optionsEl = document.getElementById("options")
        const footerEl = document.getElementById("footer")
        const wsBase = (() => {
          const url = new URL(apiBase)
          const protocol = url.protocol === "https:" ? "wss:" : "ws:"
          return `${protocol}//${url.host}`
        })()

        let socket = null
        let latestSnapshot = null
        let resolvedSessionId = initialSessionId || null

        const setStatus = (value) => {
          statusEl.textContent = value
        }

        const renderFooter = () => {
          const identityParts = []
          if (resolvedSessionId) {
            identityParts.push(`session: <code>${resolvedSessionId}</code>`)
          }
          if (sessionCode) {
            identityParts.push(`code: <code>${sessionCode}</code>`)
          }
          if (identityParts.length === 0) {
            identityParts.push("session: <code>n/a</code>")
          }
          footerEl.innerHTML =
            identityParts.join(", ") +
            (boundPollId ? `, poll: <code>${boundPollId}</code>` : ", poll: latest/open")
        }

        const resolveSessionId = async () => {
          if (resolvedSessionId) {
            return resolvedSessionId
          }
          if (!sessionCode) {
            return null
          }
          setStatus("resolving code")
          const response = await fetch(
            `${apiBase}/sessions/code/${encodeURIComponent(sessionCode)}`
          )
          if (!response.ok) {
            throw new Error(`Session code lookup failed (${response.status})`)
          }
          const session = await response.json()
          if (!session?.id || typeof session.id !== "string") {
            throw new Error("Session code lookup returned no session id")
          }
          resolvedSessionId = session.id
          return resolvedSessionId
        }

        const choosePoll = (snapshot) => {
          const polls = snapshot?.polls || []
          if (polls.length === 0) {
            return null
          }
          if (boundPollId) {
            const found = polls.find((poll) => poll.id === boundPollId)
            return found || null
          }
          return polls.find((poll) => poll.status === "open") || polls[0]
        }

        const renderPoll = (snapshot) => {
          const poll = choosePoll(snapshot)
          if (!poll) {
            questionEl.textContent = "No poll available"
            votesEl.textContent = "0 votes"
            optionsEl.innerHTML = `<p class="empty">Create and open a poll to start this game surface.</p>`
            return
          }

          const totalVotes = poll.options.reduce((sum, option) => sum + option.votes, 0)
          questionEl.textContent = poll.question
          votesEl.textContent = `${totalVotes} votes`
          const rows = poll.options
            .map((option) => {
              const ratio = totalVotes > 0 ? option.votes / totalVotes : 0
              const percent = Math.round(ratio * 100)
              const escapedLabel = option.label
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
              return `
                <article class="option">
                  <div class="label-row">
                    <span class="label">${escapedLabel}</span>
                    <span class="stats">${option.votes} (${percent}%)</span>
                  </div>
                  <div class="track">
                    <span class="fill" style="width:${percent}%"></span>
                  </div>
                </article>
              `
            })
            .join("")
          optionsEl.innerHTML = rows
        }

        const hydrate = async () => {
          try {
            resolvedSessionId = await resolveSessionId()
          } catch (err) {
            setStatus("code lookup error")
            questionEl.textContent = "Session lookup failed"
            optionsEl.innerHTML = `<p class="empty">${String(err?.message || err)}</p>`
            renderFooter()
            return
          }

          if (!resolvedSessionId) {
            setStatus("missing session")
            questionEl.textContent = "Missing required query param"
            optionsEl.innerHTML =
              `<p class="empty">Open with <code>?sessionId=&lt;id&gt;</code> or <code>?code=&lt;join_code&gt;</code></p>`
            renderFooter()
            return
          }
          renderFooter()

          try {
            setStatus("loading")
            const response = await fetch(
              `${apiBase}/sessions/${resolvedSessionId}/snapshot`
            )
            if (!response.ok) {
              throw new Error(`Snapshot request failed (${response.status})`)
            }
            latestSnapshot = await response.json()
            renderPoll(latestSnapshot)
            setStatus("live")
          } catch (err) {
            setStatus("snapshot error")
            optionsEl.innerHTML = `<p class="empty">${String(err?.message || err)}</p>`
          }
        }

        const connect = () => {
          if (!resolvedSessionId) {
            return
          }
          if (socket) {
            socket.close()
          }
          socket = new WebSocket(`${wsBase}/ws/sessions/${resolvedSessionId}`)
          setStatus("connecting")
          socket.addEventListener("open", () => setStatus("live"))
          socket.addEventListener("close", () => {
            setStatus("reconnecting")
            window.setTimeout(connect, 1200)
          })
          socket.addEventListener("message", (event) => {
            try {
              const message = JSON.parse(event.data)
              if (message.type === "session_snapshot" && message.payload?.snapshot) {
                latestSnapshot = message.payload.snapshot
              } else if (latestSnapshot) {
                if (message.payload?.poll) {
                  const next = message.payload.poll
                  const polls = latestSnapshot.polls || []
                  const index = polls.findIndex((poll) => poll.id === next.id)
                  if (index >= 0) {
                    polls[index] = next
                  } else {
                    polls.unshift(next)
                  }
                  latestSnapshot.polls = polls
                }
              }
              renderPoll(latestSnapshot)
            } catch {
              // ignore malformed socket messages in the PoC
            }
          })
        }

        hydrate().then(connect)
      })()
    </script>
  </body>
</html>
